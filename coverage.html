
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>usecase: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/willchat-ofc/api-willchat-golang/internal/data/usecase/create_chat.go (0.0%)</option>
				
				<option value="file1">github.com/willchat-ofc/api-willchat-golang/internal/infra/db/mongodb/helpers/mongo_helper.go (0.0%)</option>
				
				<option value="file2">github.com/willchat-ofc/api-willchat-golang/internal/presentation/controllers/create_chat.go (100.0%)</option>
				
				<option value="file3">github.com/willchat-ofc/api-willchat-golang/internal/utils/verify_access_token.go (0.0%)</option>
				
				<option value="file4">github.com/willchat-ofc/api-willchat-golang/tests/data_test/usecase_test/create_chat_repository.go (0.0%)</option>
				
				<option value="file5">github.com/willchat-ofc/api-willchat-golang/tests/mocks/create_chat.go (100.0%)</option>
				
				<option value="file6">github.com/willchat-ofc/api-willchat-golang/tests/mocks/create_chat_repository.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package usecase

import (
        "github.com/willchat-ofc/api-willchat-golang/internal/data/protocols"
        "github.com/willchat-ofc/api-willchat-golang/internal/domain/usecase"
)

type DbCreateChat struct {
        CreateChatRepository protocols.CreateChatRepository
}

func NewDbCreateChat(createChatRepository protocols.CreateChatRepository) *DbCreateChat <span class="cov0" title="0">{
        return &amp;DbCreateChat{
                CreateChatRepository: createChatRepository,
        }
}</span>

func (c *DbCreateChat) Create(ownerId string) (*usecase.CreateChatOutput, error) <span class="cov0" title="0">{
        chat, err := c.CreateChatRepository.Create(ownerId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;usecase.CreateChatOutput{
                Id:        chat.Id,
                OwnerId:   chat.OwnerId,
                CreatedAt: chat.CreatedAt,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package helpers

import (
        "context"
        "log"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var ctx = context.TODO()

func MongoHelper() *mongo.Database <span class="cov0" title="0">{
        clientOptions := options.Client().ApplyURI("mongodb://localhost:27017/")
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return client.Database("database")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "net/http"

        "github.com/willchat-ofc/api-willchat-golang/internal/domain/usecase"
        "github.com/willchat-ofc/api-willchat-golang/internal/presentation/helpers"
        presentationProtocols "github.com/willchat-ofc/api-willchat-golang/internal/presentation/protocols"
)

type CreateChatController struct {
        CreateChat usecase.CreateChat
}

func NewCreateChatController(createChat usecase.CreateChat) *CreateChatController <span class="cov8" title="1">{
        return &amp;CreateChatController{
                CreateChat: createChat,
        }
}</span>

type CreateChatControllerResponse struct {
        Id        string `json:"id"`
        CreatedAt string `json:"created_at"`
        OwnerId   string `json:"owner_id"`
}

func (c *CreateChatController) Handle(r presentationProtocols.HttpRequest) *presentationProtocols.HttpResponse <span class="cov8" title="1">{
        chat, err := c.CreateChat.Create(r.Header.Get("UserId"))
        if err != nil </span><span class="cov8" title="1">{
                return helpers.CreateResponse(&amp;presentationProtocols.ErrorResponse{
                        Error: "an error ocurred when creating chat",
                }, http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">return helpers.CreateResponse(&amp;CreateChatControllerResponse{
                Id:        chat.Id,
                CreatedAt: chat.CreatedAt,
                OwnerId:   chat.OwnerId,
        }, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package utils

import (
        "os"

        "github.com/golang-jwt/jwt/v5"
)

type CreateAccessTokenUtil struct{}

func NewCreateAccessTokenUtil() *CreateAccessTokenUtil <span class="cov0" title="0">{
        return &amp;CreateAccessTokenUtil{}
}</span>

func (b *CreateAccessTokenUtil) Validate(accessToken string) (*jwt.Token, jwt.MapClaims, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(accessToken, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(os.Getenv("SECRET_JWT")), nil
        }</span>)
        <span class="cov0" title="0">return token, claims, err</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package usecase_test

import (
        "errors"
        "testing"

        "github.com/golang/mock/gomock"
        "github.com/stretchr/testify/require"
        "github.com/willchat-ofc/api-willchat-golang/internal/data/usecase"
        "github.com/willchat-ofc/api-willchat-golang/tests/mocks"

        usecaseDomain "github.com/willchat-ofc/api-willchat-golang/internal/domain/usecase"
)

func setupCreateChatRepositoryMocks(t *testing.T) (*usecase.DbCreateChat, *mocks.MockCreateChatRepository, *gomock.Controller) <span class="cov0" title="0">{
        ctrl := gomock.NewController(t)
        mockCreateChatRepository := mocks.NewMockCreateChatRepository(ctrl)
        sut := usecase.NewDbCreateChat(mockCreateChatRepository)

        return sut, mockCreateChatRepository, ctrl
}</span>

func TestDbCreateChat(t *testing.T) <span class="cov0" title="0">{
        t.Run("Success", func(t *testing.T) </span><span class="cov0" title="0">{
                sut, createChatRepository, ctrl := setupCreateChatRepositoryMocks(t)
                defer ctrl.Finish()

                chatData := &amp;usecaseDomain.CreateChatOutput{
                        Id:        "fake-chat-id",
                        OwnerId:   "fake-user-id",
                        CreatedAt: "fake-created-at",
                }

                createChatRepository.EXPECT().Create("fake-user-id").Return(chatData, nil)
                res, err := sut.Create("fake-user-id")

                require.NoError(t, err)
                require.Equal(t, res, chatData)
        }</span>)

        <span class="cov0" title="0">t.Run("CreateChatRepositoryError", func(t *testing.T) </span><span class="cov0" title="0">{
                sut, createChatRepository, ctrl := setupCreateChatRepositoryMocks(t)
                defer ctrl.Finish()

                createChatRepository.EXPECT().Create("fake-user-id").Return(nil, errors.New("fake-error"))
                res, err := sut.Create("fake-user-id")

                require.Error(t, err)
                require.Nil(t, res)
        }</span>)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecase/create_chat.go

// Package mock_usecase is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        usecase "github.com/willchat-ofc/api-willchat-golang/internal/domain/usecase"
)

// MockCreateChat is a mock of CreateChat interface.
type MockCreateChat struct {
        ctrl     *gomock.Controller
        recorder *MockCreateChatMockRecorder
}

// MockCreateChatMockRecorder is the mock recorder for MockCreateChat.
type MockCreateChatMockRecorder struct {
        mock *MockCreateChat
}

// NewMockCreateChat creates a new mock instance.
func NewMockCreateChat(ctrl *gomock.Controller) *MockCreateChat <span class="cov8" title="1">{
        mock := &amp;MockCreateChat{ctrl: ctrl}
        mock.recorder = &amp;MockCreateChatMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateChat) EXPECT() *MockCreateChatMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockCreateChat) Create(ownerId string) (*usecase.CreateChatOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ownerId)
        ret0, _ := ret[0].(*usecase.CreateChatOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockCreateChatMockRecorder) Create(ownerId interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCreateChat)(nil).Create), ownerId)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/data/protocols/create_chat_repository.go

// Package mock_protocols is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        protocols "github.com/willchat-ofc/api-willchat-golang/internal/data/protocols"
)

// MockCreateChatRepository is a mock of CreateChatRepository interface.
type MockCreateChatRepository struct {
        ctrl     *gomock.Controller
        recorder *MockCreateChatRepositoryMockRecorder
}

// MockCreateChatRepositoryMockRecorder is the mock recorder for MockCreateChatRepository.
type MockCreateChatRepositoryMockRecorder struct {
        mock *MockCreateChatRepository
}

// NewMockCreateChatRepository creates a new mock instance.
func NewMockCreateChatRepository(ctrl *gomock.Controller) *MockCreateChatRepository <span class="cov0" title="0">{
        mock := &amp;MockCreateChatRepository{ctrl: ctrl}
        mock.recorder = &amp;MockCreateChatRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateChatRepository) EXPECT() *MockCreateChatRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockCreateChatRepository) Create(ownerId string) (*protocols.CreateChatRepositoryOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ownerId)
        ret0, _ := ret[0].(*protocols.CreateChatRepositoryOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockCreateChatRepositoryMockRecorder) Create(ownerId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCreateChatRepository)(nil).Create), ownerId)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
